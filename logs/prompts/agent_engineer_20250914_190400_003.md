---
timestamp: 2025-09-14T19:04:00.003917
type: agent_engineer
metadata: {"agent_type": "engineer", "agent_id": "engineer_5b35ff26-5fbd-429d-85cf-0e7d713f86ec", "session_id": "5b35ff26-5fbd-429d-85cf-0e7d713f86ec", "delegation_context": {"description": "Design and implement mcp-browser", "timestamp": "2025-09-14T19:04:00.002842"}}
---


AGENT MEMORY - PROJECT-SPECIFIC KNOWLEDGE:
# Agent Memory: engineer
<!-- Last Updated: 2025-09-14T19:03:59.997618Z -->



INSTRUCTIONS: Review your memory above before proceeding. Apply learned patterns and avoid known mistakes.


Create a complete implementation of mcp-browser based on the PRD with the following architectural requirements:

## Architecture Requirements
1. **Service-Oriented Architecture (SOA)**: Each major component should be a separate service with clear interfaces
2. **Dependency Injection (DI)**: Use constructor injection pattern with a service container
3. **File Size Limit**: No single file should exceed 500 lines
4. **Async/await**: Use asyncio throughout for all I/O operations

## Core Services to Implement

### 1. Project Structure
```
mcp-browser/
├── src/
│   ├── services/
│   │   ├── __init__.py
│   │   ├── websocket_service.py      # WebSocket server with port auto-discovery
│   │   ├── storage_service.py         # JSONL storage with rotation
│   │   ├── browser_service.py         # Browser communication handler
│   │   ├── mcp_service.py            # MCP server implementation
│   │   └── screenshot_service.py      # Playwright integration
│   ├── models/
│   │   ├── __init__.py
│   │   ├── console_message.py        # Console message data model
│   │   └── browser_state.py          # Browser state tracking
│   ├── container/
│   │   ├── __init__.py
│   │   └── service_container.py      # DI container implementation
│   ├── cli/
│   │   ├── __init__.py
│   │   └── main.py                   # CLI entry point
│   └── __init__.py
├── extension/
│   ├── manifest.json                  # Chrome extension manifest
│   ├── background.js                  # Service worker
│   ├── content.js                     # Console capture script
│   └── popup.html                     # Status indicator
├── pyproject.toml                     # Package configuration
├── README.md
└── requirements.txt
```

### 2. Service Implementations

#### WebSocket Service (src/services/websocket_service.py)
- Async WebSocket server using `websockets` library
- Port auto-discovery from 8875-8895
- Buffer messages and transmit every 2-3 seconds
- Handle multiple browser connections by port

#### Storage Service (src/services/storage_service.py)
- Store logs at ~/.browserPYMCP/browser/[port]/console.jsonl
- Implement size-based rotation at 50MB per port
- 7-day retention policy
- Async file I/O operations

#### Browser Service (src/services/browser_service.py)
- Handle incoming WebSocket messages from extension
- Parse and validate console messages
- Coordinate with storage service for persistence
- Track active browser connections by port

#### MCP Service (src/services/mcp_service.py)
- Use official `mcp` package from PyPI
- Implement three tools:
  - `browser_navigate(port, url)` - Navigate browser to URL
  - `browser_query_logs(port, last_n=100, level_filter=None)` - Query console logs
  - `browser_screenshot(port)` - Capture viewport screenshot via Playwright
- Register with MCP server

#### Screenshot Service (src/services/screenshot_service.py)
- Playwright integration for screenshots
- Capture viewport only (not full page)
- Return base64 encoded images
- Handle browser launch/cleanup

### 3. Dependency Injection Container (src/container/service_container.py)
```python
class ServiceContainer:
    def __init__(self):
        self._services = {}
        self._singletons = {}
    
    def register(self, name: str, factory: Callable, singleton: bool = True):
        """Register a service factory"""
        
    def get(self, name: str) -> Any:
        """Get a service instance"""
```

### 4. Chrome Extension (extension/)
- Manifest V3 WebExtension
- Capture all console methods (log, warn, error, debug, info)
- WebSocket connection to localhost:8875 (or discovered port)
- Visual status indicator in browser toolbar
- Buffer messages and send every 2-3 seconds
- Auto-reconnect on connection loss

### 5. CLI Entry Point (src/cli/main.py)
- Start/stop/status commands
- Show active port when service starts
- Display connected browsers
- Support for pipx installation

### 6. Data Models
- ConsoleMessage: timestamp, level, message, stack_trace, port
- BrowserState: port, connected_at, last_message_at, message_count

## Implementation Requirements

1. **No file over 500 lines** - Split large services into multiple modules if needed
2. **Type hints throughout** - Use typing module for all function signatures
3. **Async/await patterns** - All I/O operations must be async
4. **Error handling** - Graceful degradation, clear error messages
5. **Logging** - Use Python logging module with appropriate levels
6. **Configuration** - Use environment variables for configuration with sensible defaults

## Package Configuration (pyproject.toml)
- Package name: `browserpymcp`
- Entry point: `browserpymcp = src.cli.main:main`
- Dependencies: mcp, websockets, playwright, aiofiles
- Python requirement: >=3.8

## Test the Implementation
After implementing, verify:
1. WebSocket server starts and finds available port
2. Chrome extension connects and captures console messages
3. MCP tools are accessible from Claude
4. Logs are stored in JSONL format with proper rotation
5. Screenshots work via Playwright integration

Create all necessary files with complete, production-ready implementations following SOA and DI principles with no file exceeding 500 lines.